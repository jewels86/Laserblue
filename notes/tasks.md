# Task Notes
*Read [Cryptography & Security](cryptography.md) and [Proof of Performance](proof-of-performance.md) first.*

- **Task Format:**
    - **ID:** A UUID generated by the task creator.
    - **Requirements:** A list of conditions needed to complete the task.
        - **Equipment:** A list of required equipment.
        - **Location:** A set of points defining the area where the task can be completed.
        - **Reputation:** The minimum reputation required to undertake the task.
    - **Type:** The category or nature of the task.
    - **Parameters:** A list of task-specific parameters.
    - **Timestamp:** When the task was created.
    - **Deadline:** When the task is due.
    - **Requester:** The public key of the requester.
    - **Priority:** A measure of how critical the task is.
    - **Signature:** A cryptographic signature verifying the task’s origin.

- **Result Format:**
    - **ID:** A unique identifier generated by hashing the result along with the task.
    - **Task ID:** The ID of the associated task.
    - **Status:** A status code representing the state of the result.
    - **Payload:** The actual output of the task, encrypted with the requester’s public key.
    - **Signature:** A cryptographic signature verifying the result’s origin.

## Task Assignment

- **Deterministic Group Formation:**
    - All nodes are assigned to groups based on their public key and the total number of groups.
    - The total number of groups $G$ depends on the number of nodes $N$:
        $$
        G = \max(M, \lceil N / 10 \rceil)
        $$
      Where $M$ is the max number of groups in the network. This ensures there aren’t too many groups while scaling with network size.
    - Groups are assigned based on the number of groups and the public key of the node.
      $$
      \text{groupID} = \text{hash}(\text{public\_key}) \bmod G
      $$
      This method guarantees that every node computes its group assignment consistently.

- **Group Bias Calculation:**
    - Each group’s bias is mathematically determined using its identifier and a global seed $S$:
        $$
        \text{bias} = \text{hash}(\text{groupID} \,\|\, S) \bmod M
        $$
      where $M$ is a normalization factor to scale the bias into a useful range.
    - Because $G$ and $S$ are globally known, all nodes can calculate the bias for every group.

- **Task Broadcast and Weight Calculation:**
    - When a task is broadcast, its weight is calculated using:
        - The task’s priority.
        - The time since the task’s creation.
        - The time until the task’s deadline.
        - The group bias.
    - **Weight Calculation Example:**
      $$
      \text{weight} = \alpha \cdot \text{priority} + \beta \cdot f(\text{age}, \text{deadline}) + \gamma \cdot \text{bias}
      $$
      where $\alpha$, $\beta$, and $\gamma$ are tunable constants and $f(\text{age}, \text{deadline})$ is a function that quantifies temporal urgency.

- **Task Selection:**
    - Each node calculates the weights for all groups using the above formula.
    - If a node’s group weight is within the top $d$ (the node degree threshold) weights, that group is eligible to take on the task.
    - Intra-group coordination (using an internal algorithm) ensures that only one node in the group executes the task to minimize duplication.

- **Global Awareness of Groups:**
    - By defining $G$ as a function of $N$ and using a globally known seed $S$, all nodes know the complete list of group IDs and can compute each group’s bias.
    - This ensures that every node, regardless of its own group, can independently calculate and compare the weights for all groups.
